# History Navigation Redesign (Message-based)

Status: Draft (for review)
Scope: History navigation and rendering only; no change to filtering, context assembly, or provider pipelines.
NB! Redesign SHALL NOT affect: zone allocation (top, middle, bottom), modes and modal character of the app (command - top, view - middle, input - bottom zones), key mappings, Topic editor/selector, Model catalogue, Meta attributes of the messages, settings, storage, pipeline, LLM interaction, Command/filtering language, visual style of the app. The ONLY affected area is message history and only with respect to the presentation, formatting, positioning and navigation!!!
See also: `ui_layout.md`, `ui_view_reading_behaviour.md`, `scroll_positioning_spec.md`, `new_message_workflow.md`

## 1. Purpose

Replace the existing “message partitioning” navigation with a continuous rendering of each message (no DOM parts). Navigation is scroll‑based (j/k) and switches the Active Message when the viewport moves past the current message’s bounds. This preserves content integrity (code, math, markdown) while keeping discrete, keyboard‑first reading.

Source of truth for behavior: the prototype in `docs/history_view_template/`.

### 1.1 Dual purpose
- UX redesign: simplify reading/navigation by operating on messages (user/assistant), using per‑message margins/padding and fixed gradient overlays; remove artificial “parts” and any extra layout entities.
- Codebase refactor: simplify architecture and reduce complexity by removing the partitioner/parts pipeline, shrinking `interaction.js` via key‑handler extraction, and introducing a small Message Navigation Controller with clear, stable APIs.

## 2. Terms (MaiChat mapping)
- History Workspace: the inner scroll container (e.g., `#history` / `.text-container`) inside a non‑scrolling outer wrapper (`#historyPane`).
- Message Pair: renders as two blocks in order: User block, Assistant block. The assistant block includes its Meta line as its header area (meta is not a separate focusable element). Assistant block also included embedded content (such as code blocks, math formulas and others) if this content is generated by the LLM.
- Active Message: either the User block or the Assistant block of a pair; receives metadata actions (stars/flag/topic) and the visual active border.

## 3. Behavior in VIEW mode

### 3.1 Scrolling and steps
- j: scroll the inner History container down by a small step (pixels). If the current Active Message fully exits above the viewport, advance Active Message to the next message (first visible block) and apply the active border to it.
- k: scroll the inner History container up by a small step. If the current Active Message fully exits below the viewport, move Active Message to the previous message (last visible block).
- Shift+J: scroll down by a big step.
- Shift+K: scroll up by a big step.

Boundary behavior:
- Active Message changes when the current active block is completely outside the viewport on the scrolled‑to side (top/bottom), matching the prototype’s rules.

### 3.2 Message jumps
- d: jump to the next message; align the message to the top anchor (special case: if this activates the last message and it is shorter than the viewport, anchor it to the bottom).
- u: jump to the previous message; align the message to the top anchor.

### 3.3 Absolute positioning
- g: go to top of history; Active Message = first message; align it to the top.
- G: go to bottom of history; Active Message = last message; always anchor the last message to the bottom (regardless of its height), respecting margins/padding.

### 3.4 Anchoring rules
- Use per‑message margins for separation and inner padding for content layout. No dedicated outer‑gap paddings are required.
- Fading at edges is implemented by fixed gradient overlays attached to the outer wrapper (top and bottom) while content scrolls beneath.
- j/k steps are plain scroll increments; no forced re‑centering.
- Typewriter (reading) regime from the previous version is eliminated.

### 3.5 Visual cues
- Active Message: subtle border/accent (as in template) applied to the whole block (user or assistant).
- No fragment highlight: there is no separate “active fragment” or gutter indicator.
- Meta line: is rendered inside the assistant block; it does not receive separate focus.

### 3.6 Mouse interaction
- Clicking inside a user or assistant block sets Active Message to that block. But it doesn't scroll the history! 
- Since meta is inside the assistant block, clicking the meta header is equivalent to clicking the assistant block.

## 4. Rendering & DOM structure
- No DOM partitioning of message text. Each block is a single DOM element (with standard inner markup for code/math formatting in future M25).
- DOM structure (prototype‑aligned):
  - `<historyPane>` (outer wrapper; not scrollable)
    - `<gradientOverlayTop>` (overlay element; fixed within wrapper; visual fade for upward scrolling)
    - `<history>` (inner scroll container; holds messages)
      - `<message class="user">` (margin separates blocks; padding formats content)
      - `<message class="assistant">`
        - `<meta-line>` (header area inside assistant; moves with assistant block)
        - assistant content…
    - `<gradientOverlayBottom>` (overlay element; fixed within wrapper; visual fade for downward scrolling)
- Long code blocks/equations are not split; scrolling traverses across them without altering the DOM.

## 5. Settings
- scrollStepPx: default small step (prototype indicates ~200px).
- scrollBigStepPx: default big step (prototype indicates ~500px).
- smoothScroll:
  - j/k: off by default (instant for determinism).
  - d/u: on (smooth) for readability on message jumps.

## 6. Mode and actions (unchanged)
- Mode cycle: `VIEW --Enter--> INPUT --Esc--> VIEW --Esc--> COMMAND --Enter--> VIEW`.
- Metadata actions (stars/flag/topic) target Active Message (unchanged).
- WYSIWYG context remains tied to the visible set; this redesign does not change filtering or context rules.

## 7. Message Navigation Controller (new API)

Introduce a Message Navigation Controller to replace the Part Controller in VIEW mode.

State
- activeMessageId: string

Methods
- stepScroll(deltaPx): apply a scroll increment to the inner History container, then update Active Message based on viewport vs message bounds (switch when the active message fully exits on the scrolled side).
- jumpToMessage(messageId, anchor: 'top'|'bottom'): jump to a specific message (user or assistant) and align accordingly. Top anchor considers configured `messageMarginPx`. Bottom anchor aligns message bottom within the viewport while margins/overlays remain in place. Special case: last message bottom‑anchor rule.
- alignToMessage(messageId, anchor: 'top'|'bottom'|'center', animate: boolean): one‑shot alignment using the scroll controller.
- getActiveMessageRect(): return viewport‑relative rect of the active message (for debug/tests).

Integration
- History runtime exposes message block rects keyed by `messageId` (e.g., `pairId:user`, `pairId:assistant`); the controller reads them to decide active transitions.
- Scroll controller is reused; policy‑free. One‑shot ensureVisible/align operations use margins/padding (no outer‑gap concept).

## 8. Implementation plan (Parts → Messages)

### 8.1 Architecture shifts
- Replace Part Controller with a Message Navigation Controller (one‑way migration). No feature flags; direct replacement.
- Allow minimal compatibility shims during the short transition (same PR chain), but do not keep both mechanisms active at runtime.

### 8.2 Rendering changes
- History renderer outputs 2 blocks per pair: user block; assistant block that includes its meta header. Remove part IDs and partition markup.
- Define stable `messageId` for each block (e.g., `pairId:user`, `pairId:assistant`) and set it on DOM via `data-message-id` and `data-role`.
- Use `.message` elements instead of `.part` in markup and selectors; update fade/out‑of‑context logic to target `#history > .message`.
- Keep badge structure (stars/flag/topic) inside the assistant header area.

### 8.3 Key routing (VIEW)
- Replace part navigation with scroll‑based handlers: j/k/J/K call `stepScroll` with small/big deltas.
- Map d/u to message jumps (top anchor; last‑message special case). Preserve g/G as absolute jumps (first/top and last/bottom).
- Mouse: clicking a `.message` sets Active Message; do not auto‑scroll.

### 8.4 Anchoring and clamps
- Use per‑message margins and inner padding; compute anchors against message top/bottom plus configured `messageMarginPx`.
- Retain dead‑band stabilization (avoid micro‑jitter near the anchor).
- j/k = plain scroll increments (instant); d/u = smooth jumps by default; G always bottom‑anchors last message.

### 8.5 Tests (update and add)
- Long assistant with internal code block: scrolling traverses without DOM reflow; content intact.
- Boundary transitions for j/k and d/u are deterministic (switch Active Message only when fully out of view on the scrolled side; top/bottom clamps applied).
- d on last message anchors bottom if message is shorter than the viewport. G always anchors the last message to bottom. g anchors the first message to top.
- Clicking assistant header (meta) behaves like assistant block; sets Active Message accordingly.
- No regression in filter/export/provider/token budgeting tests (unchanged).

### 8.6 Sequenced steps (no dual maintenance)
- Step A — Extract key handlers (no behavior change)
  - Files: create `src/features/interaction/viewKeys.js`, `commandKeys.js`, `inputKeys.js`.
  - Move current `viewHandler`, `commandHandler`, `inputHandler` from `interaction.js` into these files; export factories; rewire `createKeyRouter`.
  - Success: build/tests pass; behavior unchanged; `interaction.js` smaller.

- Step B — Message model and render
  - Files: add `src/features/history/messageModel.js` (MessageList builder), `ActiveMessageController`.
  - Update `historyView` to render `.message.user` and `.message.assistant` (assistant contains `<meta-line>`); update out‑of‑context styling/badges for `.message`.
  - Success: visual parity; compiles with existing scroll logic.

- Step C — Scroll controller: message metrics and API
  - Update `src/features/history/scrollControllerV3.js` to measure `#history > .message`; add `stepScroll`, `jumpToMessage`, `alignToMessage`.
  - Success: deterministic positioning; margins/overlays intact.

- Step D — Wire navigation
  - VIEW: j/k/J/K → `stepScroll`; d/u/g/G per spec; click sets Active Message by `data-message-id`.
  - Success: keyboard/mouse navigation matches spec.

- Step E — Remove legacy and update tests
  - Remove `partitioner.js`, `parts.js`; update selectors, fade logic, and tests from `.part` to `.message`.
  - Success: all tests green; no references to parts/partitioner remain.

## 9. Open values for review
- Defaults: `scrollStepPx` (proposed 200), `scrollBigStepPx` (proposed 500).
- Smooth scroll policy: j/k instant, d/u smooth (proposed).
- `messageMarginPx` and `messagePaddingPx` defaults (prototype uses margin for separation and padding for inner layout).

## 10. Non‑goals / Out of scope
- No change to filtering language, o‑boundary semantics, or WYSIWYG context.
- No change to send/trimming pipeline or provider adapters.
- No virtualization changes (tracked separately in virtualization RFC).

---
This document is derived from the prototype in `docs/history_view_template/` and translates its behavior into the MaiChat vocabulary to guide implementation.
