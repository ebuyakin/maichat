# History Navigation Redesign (Message-based)

Status: Draft (for review)
Scope: History navigation and rendering only; no change to filtering, context assembly, or provider pipelines.
NB! Redesign SHALL NOT affect: zone allocation (top, middle, bottom), modes and modal character of the app (command - top, view - middle, input - bottom zones), key mappings, Topic editor/selector, Model catalogue, Meta attributes of the messages, settings, storage, pipeline, LLM interaction, Command/filtering language, visual style of the app. The ONLY affected area is message history and only with respect to the presentation, formatting, positioning and navigation!!!
See also: `ui_layout.md`, `ui_view_reading_behaviour.md`, `scroll_positioning_spec.md`, `new_message_workflow.md`

## 1. Purpose

Replace the existing “message partitioning” navigation with a continuous rendering of each message (no DOM parts). Navigation is scroll‑based (j/k) and switches the Active Message when the viewport moves past the current message’s bounds. This preserves content integrity (code, math, markdown) while keeping discrete, keyboard‑first reading.

Source of truth for behavior: the prototype in `docs/history_view_template/`.

### 1.1 Dual purpose
- UX redesign: simplify reading/navigation by operating on messages (user/assistant), using per‑message margins/padding and fixed gradient overlays; remove artificial “parts” and any extra layout entities.
- Codebase refactor: simplify architecture and reduce complexity by removing the partitioner/parts pipeline, shrinking `interaction.js` via key‑handler extraction, and introducing a small Message Navigation Controller with clear, stable APIs.

## 2. Terms (MaiChat mapping)
- History Workspace: the inner scroll container (e.g., `#history` / `.text-container`) inside a non‑scrolling outer wrapper (`#historyPane`).
- Message Pair: renders as two blocks in order: User block, Assistant block. The assistant block includes its Meta line as its header area (meta is not a separate focusable element). Assistant block also included embedded content (such as code blocks, math formulas and others) if this content is generated by the LLM.
- Active Message: either the User block or the Assistant block of a pair; receives metadata actions (stars/flag/topic) and the visual active border.

## 3. Behavior in VIEW mode

### 3.1 Scrolling and steps
- j: scroll the inner History container down by a small step (pixels). If the current Active Message fully exits above the viewport, advance Active Message to the next message (first visible block) and apply the active border to it.
- k: scroll the inner History container up by a small step. If the current Active Message fully exits below the viewport, move Active Message to the previous message (last visible block).
- Shift+J: scroll down by a big step.
- Shift+K: scroll up by a big step.

Boundary behavior:
- Active Message changes when the current active block is completely outside the viewport on the scrolled‑to side (top/bottom), matching the prototype’s rules.

### 3.2 Message jumps
- d: jump to the next message; align the message to the top anchor (special case: if this activates the last message and it is shorter than the viewport, anchor it to the bottom).
- u: jump to the previous message; align the message to the top anchor.

### 3.3 Absolute positioning
- g: go to top of history; Active Message = first message; align it to the top.
- G: go to bottom of history; Active Message = last message; always anchor the last message to the bottom (regardless of its height), respecting margins/padding.

### 3.4 Anchoring rules
- Use per‑message margins for separation and inner padding for content layout. No dedicated outer‑gap paddings are required.
- Fading at edges is implemented by fixed gradient overlays attached to the outer wrapper (top and bottom) while content scrolls beneath.
- j/k steps are plain scroll increments; no forced re‑centering.
- Typewriter (reading) regime from the previous version is eliminated.

### 3.5 Visual cues
- Active Message: subtle border/accent (as in template) applied to the whole block (user or assistant).
- No fragment highlight: there is no separate “active fragment” or gutter indicator.
- Meta line: is rendered inside the assistant block; it does not receive separate focus.

### 3.6 Mouse interaction
- Clicking inside a user or assistant block sets Active Message to that block. But it doesn't scroll the history! 
- Since meta is inside the assistant block, clicking the meta header is equivalent to clicking the assistant block.

## 4. Rendering & DOM structure
- No DOM partitioning of message text. Each block is a single DOM element (with standard inner markup for code/math formatting in future M25).
- DOM structure (prototype‑aligned):
  - `<historyPane>` (outer wrapper; not scrollable)
    - `<gradientOverlayTop>` (overlay element; fixed within wrapper; visual fade for upward scrolling)
    - `<history>` (inner scroll container; holds messages)
      - `<message class="user">` (margin separates blocks; padding formats content)
      - `<message class="assistant">`
        - `<meta-line>` (header area inside assistant; moves with assistant block)
        - assistant content…
    - `<gradientOverlayBottom>` (overlay element; fixed within wrapper; visual fade for downward scrolling)
- Long code blocks/equations are not split; scrolling traverses across them without altering the DOM.

## 5. Settings
- scrollStepPx: default small step (prototype indicates ~200px).
- scrollBigStepPx: default big step (prototype indicates ~500px).
- smoothScroll:
  - j/k: off by default (instant for determinism).
  - d/u: on (smooth) for readability on message jumps.

## 6. Mode and actions (unchanged)
- Mode cycle: `VIEW --Enter--> INPUT --Esc--> VIEW --Esc--> COMMAND --Enter--> VIEW`.
- Metadata actions (stars/flag/topic) target Active Message (unchanged).
- WYSIWYG context remains tied to the visible set; this redesign does not change filtering or context rules.

## 7. Message Navigation Controller (new API)

Introduce a Message Navigation Controller to replace the Part Controller in VIEW mode:

State
- activeMessageId: string

Methods
- Replace Part Controller with a Message Navigation Controller (one‑way migration). No feature flags; direct replacement.
- Allow minimal compatibility shims during the short transition (same PR chain), but do not keep both mechanisms active at runtime.
- alignToMessage(messageId, anchor: 'top'|'bottom'|'center', animate: boolean): one‑shot alignment using the scroll controller.
- getActiveMessageRect(): returns viewport‑relative rect of the active block (for debug/tests).

Integration
### 8.2 Rendering changes
- History renderer outputs 2 blocks per pair: user block; assistant block that includes its meta header. Remove part IDs and partition markup.
- Define stable `messageId` for each block (e.g., `pairId:user`, `pairId:assistant`) for controller/DOM coordination.
- Keep badge structure (stars/flag/topic) inside the assistant header area.
- History runtime exposes message block rects keyed by messageId (e.g., `pairId:user`, `pairId:assistant`); controller reads them to decide active transitions.
- Scroll controller is reused; no persistent policy. One‑shot ensureVisible/alignTo are applied via alignToMessage.

## 8. Migration plan (from Parts → Fragment)

### 8.1 Architecture shifts
- Replace Part Controller with Message Navigation Controller behind a feature flag `settings.messageNavigation`.
- Maintain both systems temporarily; choose at runtime based on the flag.

### 8.2 Rendering changes
- History renderer outputs 2 blocks per pair: user block; assistant block that includes its meta header. Remove part IDs and partition markup.
- Keep badge structure (stars/flag/topic) inside the assistant header area.

### 8.3 Key routing (VIEW)
- Replace part navigation with scroll‑based handlers: j/k/J/K call stepScroll with small/big deltas.
- Map d/u to message jumps (top anchor).
- Preserve g/G behaviors and ESC/ENTER mode transitions.

### 8.4 Anchoring and clamps
- Replace Outer Gap padding with per‑message margins; alignment targets compute against message top/bottom plus configured `messageMarginPx`.
- Retain dead‑band stabilization (avoid micro‑jitter near the anchor).
- j/k = plain scroll increments; d/u/g/G = one‑shot align per anchor.

### 8.5 Tests (update and add)
- Long assistant with internal code block: scrolling traverses without DOM reflow; content intact.
- Boundary transitions for j/k and d/u are deterministic (switch Active Message only when fully out of view on the scrolled side; top/bottom clamps applied).
- d on last message anchors bottom if message is shorter than the viewport. G always anchors the last message to bottom. g anchors the first message to top.
- Clicking assistant header (meta) behaves like assistant block; sets Active Message accordingly.
- No regression in filter/export/provider/token budgeting tests (unchanged).

### 8.6 Rollout
- Phase A (Flagged): ship Fragment Controller under settings flag; legacy parts remain default.
- Phase B (Default): enable fragment navigation by default; retain legacy parts under a hidden flag.
- Phase C (Remove): delete partitioner code and legacy tests after stabilization.

## 9. Open values for review
- Defaults: `scrollStepPx` (proposed 200), `scrollBigStepPx` (proposed 500).
- Smooth scroll policy: j/k instant, d/u smooth (proposed).
- `messageMarginPx` and `messagePaddingPx` defaults (prototype uses margin for separation and padding for inner layout).

## 10. Non‑goals / Out of scope
- No change to filtering language, o‑boundary semantics, or WYSIWYG context.
- No change to send/trimming pipeline or provider adapters.
- No virtualization changes (tracked separately in virtualization RFC).

---
This document is derived from the prototype in `docs/history_view_template/` and translates its behavior into the MaiChat vocabulary to guide implementation.
