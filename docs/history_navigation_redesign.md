# History Navigation Redesign (Message-based)

Status: Draft (for review)
Scope: History navigation and rendering only; no change to filtering, context assembly, or provider pipelines.
NB! Redesign SHALL NOT affect: zone allocation (top, middle, bottom), modes and modal character of the app (command - top, view - middle, input - bottom zones), key mappings, Topic editor/selector, Model catalogue, Meta attributes of the messages, settings, storage, pipeline, LLM interaction, Command/filtering language, visual style of the app. The ONLY affected area is message history and only with respect to the presentation, formatting, positioning and navigation!!!
See also: `ui_layout.md`, `ui_view_reading_behaviour.md`, `scroll_positioning_spec.md`, `new_message_workflow.md`

## 1. Purpose

Replace the existing “message partitioning” navigation with a continuous rendering of each message (no DOM parts). Navigation is scroll‑based (j/k) and switches the Active Message when the viewport moves past the current message’s bounds. This preserves content integrity (code, math, markdown) while keeping discrete, keyboard‑first reading.

Source of truth for behavior: the prototype in `docs/history_view_template/`.

### 1.1 Dual purpose
- UX redesign: simplify reading/navigation by operating on messages (user/assistant), using per‑message margins/padding and fixed gradient overlays; remove artificial “parts” and any extra layout entities.
- Codebase refactor: simplify architecture and reduce complexity by removing the partitioner/parts pipeline, shrinking `interaction.js` via key‑handler extraction, and introducing a small Message Navigation Controller with clear, stable APIs.

## 2. Terms (MaiChat mapping)
- History Workspace: the inner scroll container (e.g., `#history` / `.text-container`) inside a non‑scrolling outer wrapper (`#historyPane`).
- Message Pair: renders as two blocks in order: User block, Assistant block. The assistant block includes its Meta line as its header area (meta is not a separate focusable element). Assistant block also included embedded content (such as code blocks, math formulas and others) if this content is generated by the LLM.
- Active Message: either the User block or the Assistant block of a pair; receives metadata actions (stars/flag/topic) and the visual active border.

## 3. Behavior in VIEW mode

### 3.1 Scrolling and steps
- j: scroll the inner History container down by a small step (pixels). If the current Active Message fully exits above the viewport, advance Active Message to the next message (first visible block) and apply the active border to it.
- k: scroll the inner History container up by a small step. If the current Active Message fully exits below the viewport, move Active Message to the previous message (last visible block).
- Shift+J: scroll down by a big step.
- Shift+K: scroll up by a big step.

Boundary behavior:
- Active Message changes when the current active block is completely outside the viewport on the scrolled‑to side (top/bottom), matching the prototype’s rules.

### 3.2 Message jumps
- d: jump to the next message; align the message to the top anchor (special case: if this activates the last message and it is shorter than the viewport, anchor it to the bottom).
- u: jump to the previous message; align the message to the top anchor.

### 3.3 Absolute positioning
- g: go to top of history; Active Message = first message; align it to the top.
- G: go to bottom of history; Active Message = last message; always anchor the last message to the bottom (regardless of its height), respecting margins/padding.

### 3.4 Anchoring rules
- Use per‑message margins for separation and inner padding for content layout. No dedicated outer‑gap paddings are required.
- Fading at edges is implemented by fixed gradient overlays attached to the outer wrapper (top and bottom) while content scrolls beneath.
- j/k steps are plain scroll increments; no forced re‑centering.
- Typewriter (reading) regime from the previous version is eliminated.

### 3.5 Visual cues
- Active Message: subtle border/accent (as in template) applied to the whole block (user or assistant).
- No fragment highlight: there is no separate “active fragment” or gutter indicator.
- Meta line: is rendered inside the assistant block; it does not receive separate focus.

### 3.6 Mouse interaction
- Clicking inside a user or assistant block sets Active Message to that block. But it doesn't scroll the history! 
- Since meta is inside the assistant block, clicking the meta header is equivalent to clicking the assistant block.


## 4. Rendering & DOM structure

- No DOM partitioning of message text. Each message is a single block (with standard inner markup for code/math formatting, images, etc. in future M25).
- DOM structure (prototype‑aligned, explicit):

  ```html
  <div id="historyPane"> <!-- not scrollable -->
    <div class="gradientOverlayTop"></div>
    <div id="history"> <!-- scrollable -->
      <div class="message user" data-message-id="..." data-pair-id="..." data-role="user">
        <!-- user text -->
      </div>
      <div class="message assistant" data-message-id="..." data-pair-id="..." data-role="assistant">
        <div class="assistant-meta">
          <!-- meta badges, topic, model, error actions, etc. -->
        </div>
        <div class="assistant-body">
          <!-- assistant text, code blocks, equations, images, etc. -->
        </div>
      </div>
      <!-- ...more messages... -->
    </div>
    <div class="gradientOverlayBottom"></div>
  </div>
  ```

- Long code blocks/equations are not split; scrolling traverses across them without altering the DOM.

### 4.1 Overlays and scrolling (concise)

- Scroll container: `#history` (inner). The outer `#historyPane` is not scrollable.
- Overlays: top/bottom gradient elements live inside `#historyPane` and stay fixed; content scrolls beneath. Do not use sticky for overlays.
- Positioning contract:
  - `#historyPane`: position: relative; overflow: hidden (overlays’ positioning context and clipping).
  - `#history`: position: relative; overflow-y: auto; height: 100% (scrollable area).
  - Message separation uses per-message margin; inner padding formats content.

## 5. Settings
- scrollStepPx: default small step (prototype indicates ~200px).
- scrollBigStepPx: default big step (prototype indicates ~500px).
- smoothScroll:
  - j/k: off by default (instant for determinism).
  - d/u: on (smooth) for readability on message jumps.

## 6. Mode and actions (unchanged)
- Mode cycle: `VIEW --Enter--> INPUT --Esc--> VIEW --Esc--> COMMAND --Enter--> VIEW`.
- Metadata actions (stars/flag/topic) target Active Message (unchanged).
- WYSIWYG context remains tied to the visible set; this redesign does not change filtering or context rules.

## 7. Message Navigation Controller (new API)

Introduce a Message Navigation Controller to replace the Part Controller in VIEW mode.

State
- activeMessageId: string

Methods
- stepScroll(deltaPx): apply a scroll increment to the inner History container, then update Active Message based on viewport vs message bounds (switch when the active message fully exits on the scrolled side).
- jumpToMessage(messageId, anchor: 'top'|'bottom'): jump to a specific message (user or assistant) and align accordingly. Top anchor considers configured `messageMarginPx`. Bottom anchor aligns message bottom within the viewport while margins/overlays remain in place. Special case: last message bottom‑anchor rule.
- alignToMessage(messageId, anchor: 'top'|'bottom'|'center', animate: boolean): one‑shot alignment using the scroll controller.
- getActiveMessageRect(): return viewport‑relative rect of the active message (for debug/tests).

Integration
- History runtime exposes message block rects keyed by `messageId` (e.g., `pairId:user`, `pairId:assistant`); the controller reads them to decide active transitions.
- Scroll controller is reused; policy‑free. One‑shot ensureVisible/align operations use margins/padding (no outer‑gap concept).

## 8. Implementation plan (single stream)

One-way migration from parts → messages. No feature flags or dual maintenance. Each step is small, testable, and keeps the app runnable.

Step 1 — Extract key handlers (stabilize interaction.js)
- Create `src/features/interaction/viewKeys.js`, `commandKeys.js`, `inputKeys.js`.
- Move bodies of `viewHandler`, `commandHandler`, `inputHandler` from `interaction.js` into these files as factory functions (accepting the same dependencies they currently close over).
- Rewire `interaction.js` to import and register them via `createKeyRouter`.
- Success: build/tests pass; behavior unchanged; `interaction.js` smaller and easier to work with.

Step 2 — Message model and rendering
- Add `src/features/history/messageModel.js` with a MessageList builder mapping each pair to two messages (`pairId:user`, `pairId:assistant`).
- Add `ActiveMessageController` with `{ activeMessageId }` and helpers: `first/last/next/prev/setActiveById/active()`.
- Update `historyView` to render `.message.user` and `.message.assistant` (assistant contains `<meta-line>`). Set `data-message-id`, `data-pair-id`, `data-role` on each message node.
- Update out‑of‑context styling, badges, and counts to operate on `.message` elements.
- Success: visual parity with current UI; compiles with existing scroll logic.

Step 3 — Scroll controller: message metrics and API
- Update `src/features/history/scrollControllerV3.js` to measure `#history > .message` and compute metrics keyed by `messageId`.
- Add APIs: `stepScroll(px)`, `jumpToMessage(messageId, anchor)`, `alignToMessage(messageId, anchor, animate)`.
- Anchor math uses per‑message margins/padding; keep dead‑band (no outer gaps). Last message: always bottom‑anchor for G and when d lands on a short last message.
- Success: programmatic calls position messages deterministically with gradients/margins intact.

Step 4 — History runtime wiring
- Replace `applyActivePart` with `applyActiveMessage`; update any `.part` selectors to `.message`.
- Update fade visibility to target `#history > .message`.
- Keep context/boundary logic intact; only the presentation layer changes.
- Success: active styling and fade behavior work with message nodes.

Step 5 — Wire navigation (VIEW mode)
- In `viewKeys.js`: j/k/J/K → `stepScroll`; d/u → `jumpToMessage` (top anchor; last‑message rule); g → first/top; G → last/bottom.
- Click on `.message` sets `ActiveMessageController` by `data-message-id` (no auto‑scroll on click).
- Success: keyboard and mouse navigation match the spec precisely.

Step 6 — Remove legacy and update tests
- Remove `src/features/history/partitioner.js` and `parts.js`; delete imports and dead code paths.
- Update tests and selectors from `.part` to `.message`; add tests for last‑message bottom anchoring; ensure code/equation placeholder styling unaffected.
- Success: all tests green; no references to parts/partitioner remain.

Step 7 — Cleanup & docs
- Inline shims removed; docs updated (this file, `ui_view_reading_behaviour.md` cross‑link).
- Success: repo reflects the new, simpler architecture.

## 9. Open values for review
- Defaults: `scrollStepPx` (proposed 200), `scrollBigStepPx` (proposed 500).
- Smooth scroll policy: j/k instant, d/u smooth (proposed).
- `messageMarginPx` and `messagePaddingPx` defaults (prototype uses margin for separation and padding for inner layout).

## 10. Non‑goals / Out of scope
- No change to filtering language, o‑boundary semantics, or WYSIWYG context.
- No change to send/trimming pipeline or provider adapters.
- No virtualization changes (tracked separately in virtualization RFC).

---
This document is derived from the prototype in `docs/history_view_template/` and translates its behavior into the MaiChat vocabulary to guide implementation.



