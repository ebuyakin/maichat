// Moved from src/store/memoryStore.js (Phase 5 core move)
import { createMessagePair } from '../models/messagePair.js'
import { createTopic } from '../models/topic.js'
class Emitter { constructor(){ this.listeners={} } on(e,f){ (this.listeners[e] ||= []).push(f); return ()=>this.off(e,f) } off(e,f){ this.listeners[e] = (this.listeners[e]||[]).filter(x=>x!==f) } emit(e,p){ (this.listeners[e]||[]).forEach(fn=>fn(p)) } }
export class MemoryStore { constructor(){ this.pairs=new Map(); this.topics=new Map(); this.children=new Map(); this.emitter=new Emitter(); this.rootTopicId='root'; const root=createTopic({ id:this.rootTopicId, name:'Root', parentId:null }); root.directCount=0; root.totalCount=0; this.topics.set(this.rootTopicId, root); if(!this.children.has(null)) this.children.set(null,new Set()); this.children.get(null).add(this.rootTopicId); this.emitter.emit('topic:add', root) }
  on(e,f){ return this.emitter.on(e,f) }
  addTopic(name,parentId, createdAt){ const id=crypto.randomUUID(); const topic=createTopic({ id,name,parentId, createdAt: createdAt||Date.now() }); topic.directCount=0; topic.totalCount=0; this.topics.set(id,topic); if(!this.children.has(parentId)) this.children.set(parentId,new Set()); this.children.get(parentId).add(id); this.emitter.emit('topic:add', topic); return id }
  renameTopic(id,newName){ const t=this.topics.get(id); if(!t) return false; t.name=newName; this.emitter.emit('topic:update', t); return true }
  deleteTopic(id){ if(id===this.rootTopicId) return false; if(this.children.get(id)?.size) return false; for(const p of this.pairs.values()) if(p.topicId===id) return false; const topic=this.topics.get(id); if(!topic) return false; const parentId=topic.parentId; const existed=this.topics.delete(id); if(existed){ const set=this.children.get(parentId); if(set) set.delete(id); this.children.delete(id); this.emitter.emit('topic:delete', id); this.recalculateTopicCounts() } return !!existed }
  addMessagePair({ topicId, model, userText, assistantText }){ const id=crypto.randomUUID(); const pair=createMessagePair({ id, topicId, model, userText, assistantText }); this.pairs.set(id,pair); this.emitter.emit('pair:add', pair); this._incrementCountsForTopic(topicId); return id }
  updatePair(id,patch){ const existing=this.pairs.get(id); if(!existing) return false; const oldTopicId=existing.topicId; Object.assign(existing, patch); this.emitter.emit('pair:update', existing); if(patch.topicId && patch.topicId!==oldTopicId){ this._decrementCountsForTopic(oldTopicId); this._incrementCountsForTopic(existing.topicId) } return true }
  removePair(id){ const pair=this.pairs.get(id); if(!pair) return false; this.pairs.delete(id); this._decrementCountsForTopic(pair.topicId); this.emitter.emit('pair:delete', id); return true }
  getAllPairs(){ return Array.from(this.pairs.values()) }
  getAllTopics(){ return Array.from(this.topics.values()) }
  _importTopic(topic){ if(!this.topics.has(topic.id)){ if(typeof topic.directCount!=='number') topic.directCount=0; if(typeof topic.totalCount!=='number') topic.totalCount=0; this.topics.set(topic.id, topic); if(!this.children.has(topic.parentId)) this.children.set(topic.parentId,new Set()); this.children.get(topic.parentId).add(topic.id); this.emitter.emit('topic:add', topic) } }
  _importPair(pair){ if(!this.pairs.has(pair.id)){ this.pairs.set(pair.id, pair); this.emitter.emit('pair:add', pair) } }
  moveTopic(topicId,newParentId){ if(topicId===this.rootTopicId) return false; const topic=this.topics.get(topicId); if(!topic) return false; if(newParentId && this._isDescendant(newParentId, topicId)) return false; const oldParent=topic.parentId; if(oldParent===newParentId) return true; const oldSet=this.children.get(oldParent); if(oldSet) oldSet.delete(topicId); if(!this.children.has(newParentId)) this.children.set(newParentId,new Set()); this.children.get(newParentId).add(topicId); topic.parentId=newParentId; this.emitter.emit('topic:move', { id:topicId, from:oldParent, to:newParentId }); this.recalculateTopicCounts(); return true }
  _isDescendant(maybeChildId, ancestorId){ let cur=this.topics.get(maybeChildId); while(cur){ if(cur.id===ancestorId) return true; cur=cur.parentId ? this.topics.get(cur.parentId) : null } return false }
  recalculateTopicCounts(){ for(const t of this.topics.values()){ t.directCount=0; t.totalCount=0 } for(const p of this.pairs.values()){ const topic=this.topics.get(p.topicId); if(!topic) continue; topic.directCount++ } for(const t of this.topics.values()) t.totalCount=t.directCount; for(const t of this.topics.values()){ let cur=t.parentId ? this.topics.get(t.parentId) : null; while(cur){ cur.totalCount += t.directCount; cur=cur.parentId ? this.topics.get(cur.parentId) : null } } this.emitter.emit('topic:counts') }
  _incrementCountsForTopic(topicId){ let cur=this.topics.get(topicId); if(!cur) return; cur.directCount++; cur.totalCount++; while(cur.parentId){ cur=this.topics.get(cur.parentId); if(!cur) break; cur.totalCount++ } }
  _decrementCountsForTopic(topicId){ let cur=this.topics.get(topicId); if(!cur) return; cur.directCount=Math.max(0, cur.directCount-1); cur.totalCount=Math.max(0, cur.totalCount-1); while(cur.parentId){ cur=this.topics.get(cur.parentId); if(!cur) break; cur.totalCount=Math.max(0, cur.totalCount-1) } }
  getTopicPath(topicId){ const parts=[]; let cur=this.topics.get(topicId); while(cur){ parts.push(cur.name); cur=cur.parentId ? this.topics.get(cur.parentId) : null } return parts.reverse() }
}
export function createStore(){ return new MemoryStore() }
